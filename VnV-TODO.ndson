{"task":"Benchmark Runge-Kutta integrator accuracy vs time-step size","priority":"Medium","python_snippet":"import numpy as np\\nfrom project.integrator import runge_kutta4, analytic_solution\\nerrors = {}\\nfor dt in [1e-1, 1e-2, 1e-3, 1e-4]:\\n    sol_num = runge_kutta4(func, y0, t0, t1, dt)\\n    sol_exact = analytic_solution(np.linspace(t0, t1, int((t1-t0)/dt)+1))\\n    errors[dt] = np.max(np.abs(sol_num - sol_exact))\\nprint(errors)"}
{"task":"Cross-check 3nj symbol recursion relations via symbolic computation","priority":"Medium","python_snippet":"import sympy as sp\\nfrom project.su2_3nj import generate_3nj, recursion_3nj\\njs = [1, 2, 3, 4, 5, 6]\\nval_direct = generate_3nj(*js)\\nval_rec = recursion_3nj(*js)\\nassert sp.simplify(val_direct - val_rec) == 0"}
{"task":"Ensure reproducibility of Monte Carlo sampling routines","priority":"Low","python_snippet":"import numpy as np\\nfrom project.monte_carlo import sample_points\\nnp.random.seed(42)\\na = sample_points(1000)\\nnp.random.seed(42)\\nb = sample_points(1000)\\nassert np.array_equal(a, b)"}
